use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use syn::{Item, ItemStruct}; // <-- Added this

fn main() {
    let alg_dir_path = PathBuf::from("src/algorithms");

    println!("cargo:rerun-if-changed=src/algorithms");

    let mut algorithms = Vec::new();
    let mut mod_lines = Vec::new();

    for entry in fs::read_dir(&alg_dir_path).expect("Failed to read src/algorithms") {
        let entry = entry.expect("Failed to read directory entry");
        let path = entry.path();

        if path.is_file() {
            if let Some(ext) = path.extension() {
                if ext == "rs" {
                    if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                        if stem != "mod" {
                            let mod_name = stem.to_string();

                            // --- MODIFICATION START ---

                            // 1. Always add the module to mod.rs
                            mod_lines.push(format!("pub mod {};", mod_name));

                            // 2. Read the file content
                            let content = fs::read_to_string(&path)
                                .expect(&format!("Failed to read file: {:?}", path));

                            // 3. Parse the file
                            let file = syn::parse_file(&content)
                                .expect(&format!("Failed to parse file: {:?}", path));

                            // 4. Iterate over items to find annotated structs
                            for item in file.items {
                                if let Item::Struct(item_struct) = item {
                                    // Check if the struct has the attribute #[framework::setup]
                                    let has_setup_attr = item_struct.attrs.iter().any(|attr| {
                                        let segments = &attr.path().segments;
                                        segments.len() == 2
                                            && segments[0].ident == "framework"
                                            && segments[1].ident == "state"
                                    });

                                    if has_setup_attr {
                                        // 5. Add the (module_name, struct_name) to our list
                                        let struct_name = item_struct.ident.to_string();
                                        algorithms.push((mod_name.clone(), struct_name));
                                    }
                                }
                            }
                            // --- MODIFICATION END ---
                        }
                    }
                }
            }
        }
    }

    // Generate src/algorithms/mod.rs (this part is unchanged)
    let mod_path = alg_dir_path.join("mod.rs");
    let mut mod_file = fs::File::create(&mod_path).expect("Failed to create src/algorithms/mod.rs");
    writeln!(mod_file, "// This file is auto-generated by build.rs.").unwrap();
    for line in mod_lines {
        writeln!(mod_file, "{}", line).unwrap();
    }

    // Generate registry.rs (this part is unchanged)
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("registry.rs");
    let mut f = fs::File::create(&dest_path).unwrap();

    // Generate start_node! macro (this part is unchanged)
    writeln!(
        f,
        r#"
#[macro_export]
macro_rules! start_node {{
    (
        $algo_name:expr,
        $alg_config:expr,
        $peer_id:expr,
        $community:expr,
        $stop_signal:expr
    ) => {{
        match $algo_name.as_str() {{
"#
    )
    .unwrap();

    // This loop now correctly iterates over all found (mod_name, struct_name) pairs
    for (mod_name, struct_name) in &algorithms {
        writeln!(
            f,
            r#"
            "{struct_name}" => {{
                use futures::FutureExt;
                use distbench::algorithms::{mod_name}::{{{struct_name}Config}};
                use ::framework::AlgorithmFactory;

                let config: {struct_name}Config = serde_json::from_value($alg_config.clone())
                    .expect("Failed to deserialize into concrete config type for {struct_name}");

                let algorithm = config.build(&$community)
                    .expect("Failed to build algorithm");

                let node = ::framework::Node::new(
                    $peer_id,
                    $community,
                    algorithm,
                )
                .expect("Failed to create node");
                let signal = $stop_signal.clone();

                async move {{
                    node.start(signal).await.expect("Failed to start node").await
                }}.boxed()
            }}
        "#,
            mod_name = mod_name,
            struct_name = struct_name
        )
        .unwrap();
    }

    writeln!(
        f,
        r#"
            _ => {{
                panic!(
                    "Unknown algorithm type '{{}}'. Is the file in 'src/algorithms' and the struct marked with #[framework::setup]?",
                    $algo_name
                );
            }}
        }}
    }};
}}
"#
    )
    .unwrap();
}

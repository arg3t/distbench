use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use syn::Item;

fn main() {
    let alg_dir_path = PathBuf::from("src/algorithms");

    println!("cargo:rerun-if-changed=src/algorithms");

    let mut algorithms = Vec::new();
    let mut mod_lines = Vec::new();

    for entry in fs::read_dir(&alg_dir_path).expect("Failed to read src/algorithms") {
        let entry = entry.expect("Failed to read directory entry");
        let path = entry.path();

        if path.is_file() {
            if let Some(ext) = path.extension() {
                if ext == "rs" {
                    if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                        if stem != "mod" {
                            let mod_name = stem.to_string();

                            mod_lines.push(format!("pub mod {};", mod_name));

                            let content = fs::read_to_string(&path)
                                .expect(&format!("Failed to read file: {:?}", path));

                            let file = syn::parse_file(&content)
                                .expect(&format!("Failed to parse file: {:?}", path));

                            for item in file.items {
                                if let Item::Struct(item_struct) = item {
                                    let has_setup_attr = item_struct.attrs.iter().any(|attr| {
                                        let segments = &attr.path().segments;
                                        segments.len() == 2
                                            && segments[0].ident == "distbench"
                                            && segments[1].ident == "state"
                                    });

                                    if has_setup_attr {
                                        let struct_name = item_struct.ident.to_string();
                                        algorithms.push((mod_name.clone(), struct_name));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    let mod_path = alg_dir_path.join("mod.rs");
    let mut mod_file = fs::File::create(&mod_path).expect("Failed to create src/algorithms/mod.rs");
    writeln!(mod_file, "// This file is auto-generated by build.rs.").unwrap();
    for line in mod_lines {
        writeln!(mod_file, "{}", line).unwrap();
    }

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("registry.rs");
    let mut f = fs::File::create(&dest_path).unwrap();

    writeln!(
        f,
        r#"
#[macro_export]
macro_rules! start_node {{
    (
        $algo_name:expr,
        $alg_config:expr,
        $peer_id:expr,
        $community:expr,
        $stop_signal:expr,
        $format:expr,
        $startup_delay:expr
    ) => {{
        match $algo_name.as_str() {{
"#
    )
    .unwrap();

    for (mod_name, struct_name) in &algorithms {
        writeln!(
            f,
            r#"
            "{struct_name}" => {{
                use futures::FutureExt;
                use runner::algorithms::{mod_name}::{{{struct_name}Config}};
                use ::distbench::AlgorithmFactory;
                use ::distbench::crypto::PrivateKey;

                let config: {struct_name}Config = 
                match serde_json::from_value($alg_config.clone()) {{
                    Ok(config) => config,
                    Err(e) => {{
                        error!("Failed to deserialize into concrete config type for {struct_name}: {{}}", e);
                        return;
                    }}
                }};

                let key = PrivateKey::generate();

                let algorithm = config.build($format.clone(), key.clone(), $peer_id.clone(), $community.clone(), vec![])
                    .expect("Failed to build algorithm");

                let node = ::distbench::Node::new(
                    $peer_id.clone(),
                    key,
                    $community,
                    algorithm,
                    $format.clone(),
                )
                .expect("Failed to create node");
                let signal = $stop_signal.clone();

                async move {{
                    ($peer_id, node.start(signal, $startup_delay).await.expect("Failed to start node").await)
                }}.boxed()
            }}
        "#,
            mod_name = mod_name,
            struct_name = struct_name
        )
        .unwrap();
    }

    writeln!(
        f,
        r#"
            _ => {{
                panic!(
                    "Unknown algorithm type '{{}}'. Is the file in 'src/algorithms' and the struct marked with #[distbench::setup]?",
                    $algo_name
                );
            }}
        }}
    }};
}}
"#
    )
    .unwrap();
}

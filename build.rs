use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

fn main() {
    let alg_dir_path = PathBuf::from("src/algorithms");

    println!("cargo:rerun-if-changed=src/algorithms");

    let mut algorithms = Vec::new();
    let mut mod_lines = Vec::new();

    for entry in fs::read_dir(&alg_dir_path).expect("Failed to read src/algorithms") {
        let entry = entry.expect("Failed to read directory entry");
        let path = entry.path();

        if path.is_file() {
            if let Some(ext) = path.extension() {
                if ext == "rs" {
                    if let Some(stem) = path.file_stem().and_then(|s| s.to_str()) {
                        if stem != "mod" {
                            // We found an algorithm file
                            let mod_name = stem.to_string();
                            let struct_name = to_pascal_case(&mod_name);

                            algorithms.push((mod_name.clone(), struct_name));
                            mod_lines.push(format!("pub mod {};", mod_name));
                        }
                    }
                }
            }
        }
    }

    let mod_path = alg_dir_path.join("mod.rs");
    let mut mod_file = fs::File::create(&mod_path).expect("Failed to create src/algorithms/mod.rs");
    writeln!(mod_file, "// This file is auto-generated by build.rs.").unwrap();
    for line in mod_lines {
        writeln!(mod_file, "{}", line).unwrap();
    }

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("registry.rs");
    let mut f = fs::File::create(&dest_path).unwrap();

    writeln!(
        f,
        r#"
#[macro_export]
macro_rules! algconfig {{
    (
        $algo_name:expr,
        $config_val:expr
    ) => {{
        match $algo_name.as_str() {{
"#
    )
    .unwrap();

    for (mod_name, struct_name) in algorithms {
        writeln!(
            f,
            r#"
            "{struct_name}" => {{
                use cs4545::algorithms::{mod_name}::{{{struct_name}Config}};

                let concrete_config: {struct_name}Config = serde_json::from_value($config_val.clone())
                    .expect("Failed to deserialize into concrete config type for {struct_name}");

                concrete_config
            }}
        "#,
            mod_name = mod_name,
            struct_name = struct_name
        )
        .unwrap();
    }

    writeln!(
        f,
        r#"
            _ => {{
                panic!(
                    "Unknown algorithm type '{{}}'. Is the file in 'src/algorithms'?",
                    $algo_name
                );
            }}
        }}
    }};
}}
"#
    )
    .unwrap();
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut c = word.chars();
            match c.next() {
                None => String::new(),
                Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
            }
        })
        .collect()
}

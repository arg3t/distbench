"""Simple Broadcast algorithm using layering.

This demonstrates the algorithm layering feature:
- SimpleBroadcast: A lower-layer algorithm that handles broadcasting
- SimpleBroadcastUpper: An upper-layer algorithm that uses the lower layer
"""

from __future__ import annotations

import logging
from typing import Any

from distbench.algorithm import Algorithm
from distbench.community import PeerId
from distbench.decorators import child_algorithm, config_field, distbench, handler, message

logger = logging.getLogger(__name__)


@message
class BroadcastMessage:
    """Message to be broadcasted."""

    content: str


@distbench
class SimpleBroadcast(Algorithm):
    """Lower layer algorithm that handles broadcasting."""

    # Configuration
    is_sender: bool = config_field(default=False)

    @handler
    async def broadcast_message(self, src: PeerId, msg: BroadcastMessage) -> str | None:
        """Handle incoming broadcast message."""
        logger.info(f"SimpleBroadcast: Received '{msg.content}' from {src}")

        # Deliver to parent (if any)
        # The parent will intercept this via @handler(from_child="broadcast")
        if self._parent:
            await self.deliver_message(src, msg)

        return "Ack"

    async def broadcast(self, content: str) -> None:
        """Public method to broadcast a message."""
        msg = BroadcastMessage(content=content)

        tasks = []
        for peer in self.peers.values():
            # Call the peer method generated by @handler
            tasks.append(peer.broadcast_message(msg))

        # We don't wait for results in this simple example
        import asyncio

        await asyncio.gather(*tasks, return_exceptions=True)


@distbench
class SimpleBroadcastUpper(Algorithm):
    """Upper layer algorithm that uses SimpleBroadcast."""

    # Configuration
    start_node: bool = config_field(default=False)

    # Child algorithm
    broadcast: SimpleBroadcast = child_algorithm(SimpleBroadcast)

    # State
    messages_received: int = 0

    async def on_start(self) -> None:
        """Called when node starts."""
        if self.start_node:
            logger.info("SimpleBroadcastUpper: Starting broadcast...")
            await self.broadcast.broadcast("Hello from Upper Layer!")
        else:
            # Non-start nodes wait a bit then terminate
            # In a real algo we would wait for termination condition
            pass

    @handler(from_child="broadcast")
    async def on_broadcast(self, src: PeerId, msg: BroadcastMessage) -> None:
        """Handle message delivered from child."""
        logger.info(f"SimpleBroadcastUpper: Intercepted '{msg.content}' from child (source: {src})")
        self.messages_received += 1

        # Terminate after receiving a message
        await self.terminate()

    async def report(self) -> dict[str, str] | None:
        return {"messages_received": str(self.messages_received)}
